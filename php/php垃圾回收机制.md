内存销毁：
ZendMM在内存销毁的处理上采用与内存申请相同的策略，当程序unset一个变量或者是其他的释放行为时，ZendMM并不会直接立刻将内存交回给系统，
而是只在自身维护的内存池中将其重新标识为可用，按照内存的大小整理到上面所说的三种列表（small,large,free）之中，以备下次内存申请时使用

###php垃圾回收算法：引用计数
###5.2垃圾回收机制 PHP5.2中使用的内存回收算法是大名鼎鼎的Reference Counting，这个算法中文翻译叫做“引用计数”，其思想非常直观和简洁：为每个内存对象分配一个计数器，
####当一个内存对象建立时计数器初始化为1(因此此时总是有一个变量引用此对象)，以后每有一个新变量引用此内存对象，则计数器加1，而每当减少一个引用此内存对象的变量则计数器减1，
####当垃圾回收机制运作的时候，将所有计数器为0的内存对象销毁并回收其占用的内存。而PHP中内存对象就是zval，而计数器就是refcount__gc。
###没有专门的gc, unset时候ref_count 等于0 就删除。


###新的垃圾回收机制
####php5.3版本之后引入【【根缓冲机制】】，即php启动时默认设置指定zval数量的根缓冲区（默认是10000），【当php发现有存在循环引用的zval时】，
####就会把其投入到根缓冲区，当根缓冲区达到配置文件中的指定数量（默认是10000）后，就会进行垃圾回收，以此解决循环引用导致的内存泄漏问题

####垃圾周期：执行垃圾回收的过程叫垃圾周期，根缓存满才执行垃圾回收周期


####如何执行垃圾回收

从代码我们可以很清晰的看出这个zval的析构过程，关于引用计数字段做了以下两个操作：

如果变量的引用计数为1，即减一后引用计数为0，直接清除变量。如果当前变量如果被缓存，则需要清除缓存
如果变量的引用计数大于1，即减一后引用计数大于0，则将变量放入垃圾列表。如果变量存在引用，则去掉其引用。
将变量放入垃圾列表的操作是GC_ZVAL_CHECK_POSSIBLE_ROOT，这也是一个宏，其对应函数gc_zval_check_possible_root，但是此函数仅对数组和对象执行垃圾回收操作。
对于数组和对象变量，它会调用gc_zval_possible_root函数。

php 垃圾回收机制
1：什么是可能根
eg：$a = [111];
    $a[0] = $a;
    $a[1] = $a;
    $b = $a;
    unset($a);
    此时会把$a放入可能缓存根，因为refcount >1
    
2：何时执行回收周期 缓存根满零或是手动执行垃圾回收周期

3：如何执行垃圾回收周期
简单总结：对$a下对所有子元素执行-1操作，如果最后ref_count > 1 表示还不是垃圾比如上面的的$b = $a;即无法回收。
参考：https://www.php.net/manual/zh/features.gc.collecting-cycles.php

4：为什么要引入可能缓存根，不在unset的时候实时运行清楚垃圾，因为效率问题，实时计算太费时间。



php变量回收：unset时如果ref_gc为0就会释放内存，如果存在循环引用则被放入可能缓存跟，当缓存跟满了时就会执行gc回收内存
